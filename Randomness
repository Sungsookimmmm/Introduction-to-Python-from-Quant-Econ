import numpy as np
import matplotlib.pyplot as plt
np.random.rand()
np.random.rand(25)
np.random.rand(5, 5)

np.random.rand(2, 3, 4)

# Draw various numbers of uniform[0, 1] random variables
draws_10 = np.random.rand(10)
draws_200 = np.random.rand(200)
draws_10000 = np.random.rand(10_000)

# Plot their histograms
fig, ax = plt.subplots(3)

ax[0].set_title("Histogram with 10 draws")
ax[0].hist(draws_10)

ax[1].set_title("Histogram with 200 draws")
ax[1].hist(draws_200)

ax[2].set_title("Histogram with 10,000 draws")
ax[2].hist(draws_10000)

fig.tight_layout()
fig.savefig("histograms.png")

# To check that the mean and variance of the Uniform[0, 1] distribution are as expected
samples = np.random.rand(100000)  #    100,000 draws from Uniform(0,1)
sample_mean = np.mean(samples)
sample_variance = np.var(samples)
print("Sample mean:", sample_mean)
print("Sample variance:", sample_variance)
print(1/2)  # Theoretical mean
print(1/12) # Theoretical variance

#Discrete Distributions

# You'll see why we call it `_slow` soon :)
def simulate_loan_repayments_slow(N, r=0.05, repayment_full=25_000.0,
                                  repayment_part=12_500.0):
    repayment_sims = np.zeros(N)
    for i in range(N):
        x = np.random.rand()  # Draw a random number

        # Full repayment 75% of time
        if x < 0.75:
            repaid = repayment_full
        elif x < 0.95:
            repaid = repayment_part
        else:
            repaid = 0.0

        repayment_sims[i] = (1 / (1 + r)) * repaid

    return repayment_sims

print(np.mean(simulate_loan_repayments_slow(25_000)))

#Aside: Vectorized Computations

def simulate_loan_repayments(N, r=0.05, repayment_full=25_000.0,
                             repayment_part=12_500.0):
    """
    Simulate present value of N loans given values for discount rate and
    repayment values
    """
    random_numbers = np.random.rand(N)

    # start as 0 -- no repayment
    repayment_sims = np.zeros(N)

    # adjust for full and partial repayment
    partial = random_numbers <= 0.20
    repayment_sims[partial] = repayment_part

    full = ~partial & (random_numbers <= 0.95)
    repayment_sims[full] = repayment_full

    repayment_sims = (1 / (1 + r)) * repayment_sims

    return repayment_sims
print  (simulate_loan_repayments(25_000))

np.mean(simulate_loan_repayments(25_000))

#Demonstrate the time difference in running both functions

import timeit

slow_time = timeit.timeit(lambda: simulate_loan_repayments_slow(250_000), number=10)
fast_time = timeit.timeit(lambda: simulate_loan_repayments(250_000), number=10)

print(f"Slow version time (10 runs): {slow_time:.4f} seconds")
print(f"Fast version time (10 runs): {fast_time:.4f} seconds")

#Aside: Using Class to Hold Parameters

def simulate_loan_repayments_2(N, params):    
    # Extract fields from params object
    r = params.r
    repayment_part = params.repayment_part
    repayment_full = params.repayment_full

    random_numbers = np.random.rand(N)

    # start as 0 -- no repayment
    repayment_sims = np.zeros(N)

    # adjust for full and partial repayment
    partial = random_numbers <= 0.20
    repayment_sims[partial] = repayment_part

    full = ~partial & (random_numbers <= 0.95)
    repayment_sims[full] = repayment_full

    repayment_sims = (1 / (1 + r)) * repayment_sims

    return repayment_sims

class LoanRepaymentParams:
    # A special function 'constructor'
    def __init__(self, r, repayment_full, repayment_part):
        self.r = r
        self.repayment_full = repayment_full
        self.repayment_part = repayment_part

# Create an instance of the class        
params = LoanRepaymentParams(0.05, 50_000.0, 25_000)
print(params.r)
print(params.repayment_full)

N = 1000
params = LoanRepaymentParams(0.05, 50_000.0, 25_000)
print(np.mean(simulate_loan_repayments_2(N, params)))

class LoanRepaymentParams2:
    def __init__(self, r, repayment_full, partial_fraction = 0.3):
        self.r = r
        self.repayment_full = repayment_full
        
        # This does a calculation and sets a new value
        self.repayment_part = repayment_full * partial_fraction

# Create an instance of the class        
params = LoanRepaymentParams2(0.05, 50_000.0, 0.5)        
print(params.repayment_part) # Acccess the calculation
print(np.mean(simulate_loan_repayments_2(N, params)))


#datacalsses

from dataclasses import dataclass

@dataclass # @dataclass automatically creates __init__, __repr__, and other useful methods.
class LoanRepaymentParams3:
    r: float = 0.05
    repayment_full: float = 50_000
    repayment_part: float = 25_000

params = LoanRepaymentParams3() # uses all defaults
params2 = LoanRepaymentParams3(repayment_full= 60_000) # changes the full repayment amount

# show the objects
print(params)
print(params2)

# simulate using the new object
print(np.mean(simulate_loan_repayments_2(N, params2)))

#Profitability Threshold. 

def simulate_year_of_loans(N=250, K=1000):

    # Create array where we store the values
    avg_repayments = np.zeros(K)
    for year in range(K):

        repaid_year = 0.0
        n_loans = simulate_loan_repayments(N)
        avg_repayments[year] = n_loans.mean()

    return avg_repayments

loan_repayment_outcomes = simulate_year_of_loans(N=250)
print  (loan_repayment_outcomes)
print("Mean repayment over 1000 years:", np.mean(loan_repayment_outcomes))
# Think about why we use the 5th percentile of outcomes to
# compute when we are profitable 95% of time
lro_5 = np.percentile(loan_repayment_outcomes, 5)

print("The largest loan size such that we were profitable 95% of time is \n")
print(lro_5)

#Loan States

def simulate_loan_lifetime(monthly_payment):

    # Create arrays to store outputs
    payments = np.zeros(12)
    # Note: dtype 'U12' means a string with no more than 12 characters
    statuses = np.array(4*["repaying", "delinquency", "default"], dtype="U12")

    # Everyone is repaying during their first month
    payments[0] = monthly_payment
    statuses[0] = "repaying"

    for month in range(1, 12):
        rn = np.random.rand()

        if (statuses[month-1] == "repaying"):
            if rn < 0.85:
                payments[month] = monthly_payment
                statuses[month] = "repaying"
            elif rn < 0.95:
                payments[month] = 0.0
                statuses[month] = "delinquency"
            else:
                payments[month] = 0.0
                statuses[month] = "default"
        elif (statuses[month-1] == "delinquency"):
            if rn < 0.25:
                payments[month] = monthly_payment
                statuses[month] = "repaying"
            elif rn < 0.85:
                payments[month] = 0.0
                statuses[month] = "delinquency"
            else:
                payments[month] = 0.0
                statuses[month] = "default"
        else:  # Default -- Stays in default after it gets there
            payments[month] = 0.0
            statuses[month] = "default"

    return payments, statuses


# A Markov Chain

# 1. State description
state_values = ["repaying", "delinquency", "default"]

# 2. Transition probabilities: encoded in a matrix (2d-array) where element [i, j]
# is the probability of moving from state i to state j
P = np.array([[0.85, 0.1, 0.05], [0.25, 0.6, 0.15], [0, 0, 1]])

# 3. Initial distribution: assume loans start in repayment
x0 = np.array([1, 0, 0])


import quantecon as qe
mc = qe.markov.MarkovChain(P, state_values)
mc.simulate(5, init="repaying")
mc.simulate(12, init="repaying")
x = x0
for t in range(10):
    print(f"At time {t} the distribution is {x}")
    x = mc.P.T @ x

#Exercise 2

import numpy as np
import quantecon as qe

P = np.array([[0.85, 0.1, 0.05], [0.25, 0.6, 0.15], [0, 0, 1]])
state_values = ["repaying", "delinquency", "default"]

mc = qe.markov.MarkovChain(P, state_values)
stationary = mc.stationary_distributions  # returns an array of stationary distributions

print(stationary)
# Expected: [[0., 0., 1.]]

# Exercise 3

# Parameters (fill these with your lecture values)

alpha = 0.05   # 5% lose jobs
pi    = 0.1    # 10% find jobs

P = np.array([
    [1 - alpha, alpha],
    [pi, 1 - pi]
])

states = ["employed", "unemployed"]
mc = qe.markov.MarkovChain(P, states)

# Initial distribution
pi0 = np.array([0.9, 0.1])


def build_unemployment_chain(alpha=0.05, pi=0.1):
    """
    Construct a MarkovChain instance for the unemployment model.

    Parameters
    ----------
    alpha : float
        Fraction of employed workers who lose jobs per year.
    pi : float
        Fraction of unemployed workers who find jobs per year.

    Returns
    -------
    mc : qe.markov.MarkovChain
        The MarkovChain object with states ["employed", "unemployed"].
    """
    # Transition matrix
    P = np.array([
        [1 - alpha, alpha],   # Row for employed
        [pi, 1 - pi]          # Row for unemployed
    ])

    # State labels
    states = ["employed", "unemployed"]

    # Construct MarkovChain instance
    mc = qe.markov.MarkovChain(P, states)
    return mc

# Build the chain with your parameters
mc = build_unemployment_chain(alpha=0.05, pi=0.1)

# Check transition matrix and states
print("Transition matrix:\n", mc.P)
print("States:", mc.state_values)

# --- Simulation ---
n_simulations = 30
n_periods = 50

# Simulate 30 chains of 50 periods each, starting from employed
simulations = np.array([mc.simulate(n_periods, init="employed") for _ in range(n_simulations)])

# Convert to binary (1 = employed, 0 = unemployed)
binary = (simulations == "employed").astype(int)

import matplotlib.pyplot as plt

# Plot the simulations
fig, ax = plt.subplots(figsize=(10, 6))
for i in range(n_simulations):
    ax.plot(binary[i], alpha=0.05)
ax.set_title("Employment status over time (1 = employed, 0 = unemployed)")
ax.set_xlabel("Time")
ax.set_ylabel("Employment status")
plt.tight_layout()
plt.savefig("employment_simulation.png")
plt.show()


# --- Stationary distribution ---
stationary = mc.stationary_distributions[0]  # [p_employed, p_unemployed]

# --- Long-run average payment ---
wages = np.array([10, 1])  # employed earns $10, unemployed earns $1
long_run_payment = stationary @ wages

print("Transition matrix:\n", P)
print("Stationary distribution:", stationary)
print("Average long-run payment per worker:", long_run_payment)

#Continuous Distributions

# scipy is an extension of numpy, and the stats
# subpackage has tools for working with various probability distributions
import scipy.stats as st

x = np.linspace(-5, 5, 100)

# NOTE: first argument to st.norm is mean, second is standard deviation sigma (not sigma^2)
pdf_x = st.norm(0.0, 1.0).pdf(x)

fig, ax = plt.subplots()

ax.set_title(r"Normal Distribution ($\mu = 0, \sigma = 1$)")
ax.plot(x, pdf_x)
plt.tight_layout()
plt.show()
plt.savefig("Normal_Distribution.png")

# Gamma Distribution with different k and theta parameters

def plot_gamma(k, theta, x, ax=None):
    if ax is None:
        _, ax = plt.subplots()

    # scipy refers to the rate parameter beta as a scale parameter
    pdf_x = st.gamma(k, scale=theta).pdf(x)
    ax.plot(x, pdf_x, label=f"k = {k}  theta = {theta}")

    return ax

fig, ax = plt.subplots(figsize=(10, 6))
x = np.linspace(0.1, 20, 130)
plot_gamma(2.0, 1.0, x, ax)
plot_gamma(3.0, 1.0, x, ax)
plot_gamma(3.0, 2.0, x, ax)
plot_gamma(3.0, 0.5, x, ax)
ax.set_ylim((0, 0.6))
ax.set_xlim((0, 20))
ax.legend();
plt.tight_layout()
plt.show()
plt.savefig("Gamma_Distributions.png")

#Exercise 4

import scipy.stats as st

# Normal distribution asset
normal_asset = st.norm(loc=10, scale=5)
print("Mean:", normal_asset.mean())
print("Median:", normal_asset.median())
print("Variance:", normal_asset.var())

# Gamma distribution asset
gamma_asset = st.gamma(a=5.3, scale=2)
print("Mean:", gamma_asset.mean())
print("Median:", gamma_asset.median())
print("Variance:", gamma_asset.var())

gamma_asset = st.gamma(a=5, scale=2)
print("Mean:", gamma_asset.mean())
print("Median:", gamma_asset.median())
print("Variance:", gamma_asset.var())
